---
title: Browser-callable Services
description: A browser-callable service is a Java class that its public methods are exposed so to call it from client-side TypeScript code.
order: 30
---
:lit:
// tag::content[]

= Browser-callable services for Accessing Java Backend

A _browser-callable service_ in Hilla is a class that defines one or more public methods, and is annotated with the `@BrowserCallable` annotation.

Hilla bridges Java backend services and a TypeScript frontend. It generates TypeScript clients to call the Java backend in a type-safe way. The <<../reference/endpoint-generator#,Browser-callable service generator>> reference page contains details about the generator itself.

.Hilla browser-callable services depend on Spring Boot auto-configuration.
[IMPORTANT]
Hilla browser-callable services don't work if auto-configuration is disabled, such as when you use `@EnableWebMvc`. As a workaround, remove the `@EnableWebMvc` annotation, as described in the link:https://docs.spring.io/spring-boot/docs/2.3.4.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-auto-configuration[Spring Boot documentation]. If you have a suggestion as to how to make it more useful, please share your idea on link:https://github.com/vaadin/hilla/issues/new/[GitHub].


[[creating]]
== Creating a browser-callable service

A browser-callable service is a Java class annotated with `@BrowserCallable`:

[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/fusion/accessingbackend/CounterService.java[tags=snippet]
----

When the application starts, Hilla scans the classpath for `@BrowserCallable`-annotated classes. For each request to access a public method in a Hilla browser-callable service, a permission check is carried out. `@AnonymousAllowed` means that Hilla permits anyone to call the method from the client side.

Refer to the <<security#, Security>> article for details of configuring browser-callable service access.

.Browser-callable Service and Service terms are used interchangeably
[NOTE]
For brevity, in the rest of this article, the terms _browser-callable service_ and _Service_ are used interchangeably. The same applies to the terms _browser-callable service method_ and _service method_. The term _browser-callable service class_ is used to refer to the Java class annotated with `@BrowserCallable`.


== Modules Generated from Hilla Browser-callable services

Hilla generates a TypeScript module for every Hilla browser-callable service of the backend. Each such module exports all the public methods from the respective service class.

You can import an entire module from the https://basarat.gitbook.io/typescript/main-1/barrel[barrel] file, import all methods as a module from the service file, or select individual service methods. For example, the [filename]`CounterService.ts` could be used as in the following snippets:

.`index.ts` (import the whole service module object from the barrel file)
[[index.ts]]
[source,typescript]
----
include::{root}/frontend/demo/fusion/application/accessing-backend/ts-imports/barrel.ts[]
----

[NOTE]
The barrel file exports all the services at once. Therefore, you can import multiple services using a single import.

.`index.ts` (import all imports as a service object)
[source,typescript]
----
include::{root}/frontend/demo/fusion/application/accessing-backend/ts-imports/asterisk.ts[]
----

.`index.ts` (import a single service method)
[source,typescript]
----
include::{root}/frontend/demo/fusion/application/accessing-backend/ts-imports/method.ts[]
----

pass:[<!-- vale Vaadin.Terms-FrontendBackend = NO -->]

.Frontend Directory Alias
[NOTE]
====
The `'Frontend/'` path prefix is an alias for the `{project.basedir}/frontend` directory in your application project.

Hilla has this path alias in <<../reference/configuration#ts-compiler-options,the default TypeScript compiler configuration>> ([filename]`tsconfig.json`); the Vite configuration file ([filename]`vite.generated.js`) respects the `tsconfig` aliases by default.

Using this path alias is recommended since it allows for absolute import paths, rather than traversing the directory hierarchy in relative imports.
====

pass:[<!-- vale Vaadin.Terms-FrontendBackend = YES -->]

Hilla generates the TypeScript modules automatically when you compile the application, as well as when the application is running in development mode.

By default, the generated files are located under `{project.basedir}/frontend/generated`. You can change the folder by providing the path for the generator in the `generatedFrontendDirectory` property for the Hilla Maven plugin.

Hilla handles conversion between Java and TypeScript types. For more information about supported types, see <<../reference/type-conversion#, Type conversion>>.


== TypeScript Module Content Example

The generated TypeScript module for the Java browser-callable service defined in <<creating,`CounterService.java`>>, for example, would look as follows:

.`CounterService.ts`
[source,typescript]
----
include::{root}/frontend/generated/CounterService.ts[]
----


== Objects

A browser-callable service method can return or receive a parameter as an object (i.e., a non-primitive type). In this case, the generator also creates a TypeScript interface for the object.

An object can be defined in the following ways:

- In a separate class that belongs to the project.
- In a class that belongs to the project dependency.
- In an inner class of a browser-callable service or any other class.

.`City.java`
[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/fusion/accessingbackend/City.java[]
----

.`CountryService.java`
[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/fusion/accessingbackend/CountryService.java[]
----

The TypeScript output is the following:

.`City.ts`
[source,typescript]
----
include::{root}/frontend/generated/com/vaadin/demo/fusion/accessingbackend/City.ts[]
----

.`Query.ts`
[source,typescript]
----
include::{root}/frontend/generated/com/vaadin/demo/fusion/accessingbackend/CountryService/Query.ts[]
----

.`CountryService.ts`
[source,typescript]
----
include::{root}/frontend/generated/CountryService.ts[]
----


=== Nullable & Non-Nullable Types

See <<../reference/type-nullability#, Type nullability>> for more information about how the nullability algorithm works and how to make types non-nullable.


ifndef::react[]
// TODO adapt to React
[[cancelling-requests]]
[role="since:dev.hilla:hilla@v1.2"]
== Cancelling Requests to Browser-callable Services

Sometimes it can be useful to cancel programmatically some requests. For example, when a request is taking too long or is waiting in a queue despite no longer being needed. Hilla allows developers to cancel requests using standard https://developer.mozilla.org/en-US/docs/Web/API/AbortController[AbortController].

All browser-callable service requests support an optional parameter that can be used to pass an `AbortSignal` which allows them to be cancelled. It's worth remembering, though, that a single `AbortController` can be used to cancel multiple requests by passing its `signal` to all of them.

The following example creates two buttons: one that makes requests to a slow service method, and another that triggers the cancellation of previously created requests. If a request is subject to cancellation, errors must be handled as the service method throws `AbortError`.

[source,typescript]
----
private abortController = new AbortController();

render() {
  return html`
    <div>
      <vaadin-button @click=${this.makeRequest}>Make a request</vaadin-button>
      <vaadin-button @click=${this.cancelRequest}>Cancel pending requests</vaadin-button>
    </div>
  `;
}

async makeRequest() {
  console.log("Making request");

  try {
    const serverResponse = await HelloWorldService.slow({ signal: this.abortController.signal });
    Notification.show(serverResponse);
  } catch (error: any) {
    if (error.name === 'AbortError') {
      Notification.show("Request aborted");
    } else {
      throw error;
    }
  }
}

cancelRequest() {
  console.log("Cancelling request(s)");
  this.abortController.abort();
  this.abortController = new AbortController();
}
----
endif::[]


== Browser-callable Service URLs

Hilla automatically generates backend service URLs and wraps them in the generated TypeScript API so the developer doesn't have to worry about them.

Even though you can access any public method in any Hilla browser-callable service with the `\http://${base_url}/${prefix}/${service_class_name}/${method_name}` URL format, don't use those URLs directly. Instead, use the TypeScript methods.

. The `${base_url}` is the base URL of the application, depending on the framework used. For instance, for the Spring framework the default URL, if the application is started locally, is `http://localhost:8080`. If the application is started with a context, it should be added to the end: such as, `\http://localhost:8080/my-app`.

. The `${prefix}` is the URL common part that every exposed browser-callable service contains. By default, `connect` is used, but this can be configured in the application properties.

. The `${service_class_name}` is the corresponding Java class name annotated by `@BrowserCallable`.

. The `${method_name}` is the public method name from the Java class.

For an application started locally with the [classname]`CounterService` service defined as shown, the URL is: `\http://localhost:8080/connect/counterservice/addone`

[source,java]
----
@BrowserCallable
public class CounterService {

    public int addOne(int number) {
        return number + 1;
    }
}
----

.Browser-callable service URLs Aren't Case-Sensitive
[NOTE]
The browser-callable service name and the method name aren't case-sensitive in Hilla. Therefore, the URL shown is the same as `\http://localhost:8080/connect/CounterService/addOne` or `\http://localhost:8080/connect/COUNTERSERVICE/ADDONE`, or any other case combination for the browser-callable service and method name.


=== Configuring Browser-callable Service URLs

You can configure the `${prefix}` part of the URL. The default value is `connect`. To change it to some other value, provide an [filename]`application.properties` file in the project resources ([filename]`src/main/resources/application.properties`) and set the `vaadin.endpoint.prefix` property to the new value.

== Browser-callable Service Method Validation

The parameters of a service method are automatically validated and, if validation fails, a corresponding response is sent back to the browser.

// Skipping JSR
pass:[<!-- vale Vaadin.Abbr = NO -->]

Whenever a service method is invoked, its parameters are automatically validated using the https://beanvalidation.org/2.0/[JSR 380] Bean validation specification after they're deserialized from the request body.

pass:[<!-- vale Vaadin.Abbr = YES -->]

This is useful in eliminating the boilerplate needed for the initial request validation. The framework automatically checks the constraints placed on beans and sends the response back to the client side if the validation fails. The browser raises an [classname]`EndpointValidationError` when it receives the corresponding response from the server.


=== Built-In Validation Constraints

The built-in validation constraints are the set of annotations provided by the `jakarta.validation.validation-api` dependency. They're intended to be placed on Java beans on the server side.

You can find a full list of the constraints at https://beanvalidation.org/2.0/spec/#builtinconstraints

To use these annotations, add them to the class field or method parameter. For example:

[source,java]
----
public class Account {

  @Positive
  private Long id;

  @NotEmpty(message = "Each account must have a non-empty username")
  private String username;

  private void sendAccountData(@NotNull String destination) {
    // ...
  }
}
----


=== Custom Validation Constraints

It's possible to create custom constraints. To do this, you need to create a custom annotation and a custom validator.

See the https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-customconstraints[official documentation] for more details.


=== Manual Validation

Since all the dependencies needed for validating beans and methods are present, you can reuse them in any part of your project -- not only in the browser-callable service methods. For example:

[source,java]
----
// A validator for validating beans
Validator validator = Validation.buildDefaultValidatorFactory().getValidator();
// non-empty set if there are any constraint validation errors
Set<ConstraintViolation<Object>> violations = validator.validate(bean);

// A validator for validating methods and constructors (return values, parameters)
ExecutableValidator executableValidator = validator.forExecutables();
// non-empty set if there are any constraint validation errors
Set<ConstraintViolation<Object>> violations = executableValidator.validateReturnValue(object, method, returnValue);
----

If required, you can throw an [classname]`EndpointValidationException` from a service method. This exception is caught by TypeScript and the corresponding [classname]`EndpointValidationError` is raised.

See the official documentation for more details on https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-validating-bean-constraints[validating bean constraints] and https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-validating-executable-constraints[validating method constraints].


=== Hilla Validation Implementation Details

Hilla validates only the beans and method parameters that are used in the browser-callable service classes (i.e., classes with the `@BrowserCallable` annotation). No other types are validated, even if they have constraint annotations.

If any validation errors occur, a non-`200` response is sent back, which is interpreted in TypeScript as a reason to throw an [classname]`EndpointValidationError`. A similar effect is achieved if an [classname]`EndpointValidationException` is thrown by any of the Java browser-callable service methods.


[[error-handling]]
== Error Handling

A robust client implementation should be able to handle invalid service calls, errors on the server side, and network outages.

Hilla determines the success of a service call by inspecting the HTTP status code. The server returns the https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200[200 OK] code when it's able successfully to process the request, deserialize the method body, find and execute the particular method in the service, and serialize its return value into a response.

If the status code of the response isn't `200 OK`, Hilla throws an error on the client side. The available parameters in the error and the specific class of the thrown error depend on the failure mode. The most common ones are described in the next sub-sections.


=== Missing Browser-callable Service

If the request addresses a service or a method name not present on the backend, the server responds with https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404[404 Not Found] and Hilla raises an error of type `EndpointError`.


=== Parameter Validation Error

If the method called in the request exists on the backend, but the parameter count and types don't match the service method, the server responds with https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400[400 Bad Request] and Hilla raises an error of type [classname]`EndpointValidationException`. The error instance contains a field `validationErrorData` holding validation error information for each invalid parameter. See <<../reference/type-conversion#,Type conversion between JavaScript and Java>> for more details about the type conversion rules.

For example, the following service method expects a `java.time.LocalDate` parameter:

[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/fusion/errorhandling/DateService.java[]
----

A call with an illegal data parameter raises an [classname]`EndpointValidationException` with information about which parameters failed validation:

[source,typescript]
----
include::{root}/frontend/demo/fusion/errorhandling/catch-invalid-args.ts[]
----

ifdef::lit[]
Note that when using <<forms/binder-validation#,server-side form validation>>, validation exceptions from the server are handled automatically by the form binder.
endif::lit[]


=== Server-Side Errors

If the service exists and its parameters could be passed, but its execution raises a Java runtime exception, the server responds with
https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500[500 Internal Server Error]. When this happens, Hilla raises an error of type [classname]`EndpointError`. As a special case, if the server-side exception is an instance of [classname]`dev.hilla.exception.EndpointException` or a subclass, the server instead responds with https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400[400 Bad Request]. Then the exception type and message passed to the [classname]`EndpointException` in Java are available in the [classname]`EndpointError` instance via the `type` and `message` attributes.

The following service implementation is an example of this:

[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/pwa/offline/DataService.java[]
----

The following client-side call to the service method logs the error message and exception type:

[source,typescript]
----
include::{root}/frontend/demo/fusion/errorhandling/catch-error.ts[]
----


=== Network Errors

When the server isn't reachable due to outage or network disruption, a service call results in a low-level network error, different from [classname]`EndpointError`. Applications that support offline mode can wrap service calls with exception-handling code returning a fallback value, by distinguishing between the error classes as follows:

[source,typescript]
----
include::{root}/frontend/demo/pwa/offline/ts-view-with-endpoint.ts[]
----

See the documentation about <<client-caching#,caching service data in local storage>> using a generic wrapper.


=== Unexpected Response Contents

If the server replies with a response other than `200 OK`, and the string contained in the response isn't valid JSON, an [classname]`EndpointResponseError` is raised. The exception contains the response text as a message and the https://developer.mozilla.org/en-US/docs/Web/API/Response[Response] object in the `response` field.


ifndef::react[]
// TODO adapt to React
[role="since:dev.hilla:hilla@v1.2"]
=== Cancelled Requests

When a request is cancelled programmatically, the service call promise resolves with an `AbortError`. This happens only when you explicitly cancel a request, as explained in <<cancelling-requests>>.
endif::[]


== Code Completion in IDEs

As you can see in the earlier [filename]`CounterService.ts` example, the Javadoc for the `@BrowserCallable` class is copied to the generated TypeScript file, and the type definitions are maintained. This helps code completion to work -- at least in Visual Studio Code and IntelliJ IDEA Ultimate Edition.

.Code Completion in Visual Studio Code
[.subtle]
image::images/codecompletion.gif[Code-completion]

// end::content[]
